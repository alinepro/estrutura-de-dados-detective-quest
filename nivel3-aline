#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TAM_HASH 10

//   STRUCT Sala ‚Äì n√≥ da √°rvore bin√°ria da mans√£o
   
typedef struct Sala {
    char nome[50];
    char pista[100];
    struct Sala* esquerda;
    struct Sala* direita;
} Sala;

//   STRUCT PistaNode ‚Äì n√≥ da BST de pistas
  
typedef struct PistaNode {
    char pista[100];
    struct PistaNode* esquerda;
    struct PistaNode* direita;
} PistaNode;

//   STRUCT HashNode ‚Äì n√≥ da tabela hash (encadeamento)
  
typedef struct HashNode {
    char pista[100];
    char suspeito[50];
    struct HashNode* prox;
} HashNode;

HashNode* tabelaHash[TAM_HASH];

//   FUN√á√ÉO HASH ‚Äì soma ASCII simples
   
int funcaoHash(const char* chave) {
    int soma = 0;
    for (int i = 0; chave[i] != '\0'; i++)
        soma += chave[i];
    return soma % TAM_HASH;
}

//   criarSala ‚Äì cria dinamicamente um c√¥modo
   
Sala* criarSala(const char* nome, const char* pista) {
    Sala* nova = (Sala*) malloc(sizeof(Sala));
    strcpy(nova->nome, nome);
    strcpy(nova->pista, pista);
    nova->esquerda = NULL;
    nova->direita = NULL;
    return nova;
}

//   inserirPista ‚Äì insere pista na BST ordenadamente

PistaNode* inserirPista(PistaNode* raiz, const char* pista) {
    if (raiz == NULL) {
        PistaNode* novo = (PistaNode*) malloc(sizeof(PistaNode));
        strcpy(novo->pista, pista);
        novo->esquerda = novo->direita = NULL;
        return novo;
    }

    if (strcmp(pista, raiz->pista) < 0)
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    else if (strcmp(pista, raiz->pista) > 0)
        raiz->direita = inserirPista(raiz->direita, pista);

    return raiz;
}

//   exibirPistas ‚Äì percorre BST em ordem
   
void exibirPistas(PistaNode* raiz) {
    if (raiz != NULL) {
        exibirPistas(raiz->esquerda);
        printf("- %s\n", raiz->pista);
        exibirPistas(raiz->direita);
    }
}

//   inserirNaHash ‚Äì associa pista a suspeito
 
void inserirNaHash(const char* pista, const char* suspeito) {
    int indice = funcaoHash(pista);

    HashNode* novo = (HashNode*) malloc(sizeof(HashNode));
    strcpy(novo->pista, pista);
    strcpy(novo->suspeito, suspeito);
    novo->prox = tabelaHash[indice];
    tabelaHash[indice] = novo;
}

//   encontrarSuspeito ‚Äì busca suspeito de uma pista
  
char* encontrarSuspeito(const char* pista) {
    int indice = funcaoHash(pista);
    HashNode* atual = tabelaHash[indice];

    while (atual != NULL) {
        if (strcmp(atual->pista, pista) == 0)
            return atual->suspeito;
        atual = atual->prox;
    }
    return NULL;
}

//   contarPistasSuspeito ‚Äì percorre BST e conta ocorr√™ncias
   
int contarPistasSuspeito(PistaNode* raiz, const char* suspeito) {
    if (raiz == NULL)
        return 0;

    int total = 0;
    char* suspeitoEncontrado = encontrarSuspeito(raiz->pista);

    if (suspeitoEncontrado != NULL &&
        strcmp(suspeitoEncontrado, suspeito) == 0)
        total++;

    total += contarPistasSuspeito(raiz->esquerda, suspeito);
    total += contarPistasSuspeito(raiz->direita, suspeito);

    return total;
}

//   explorarSalas ‚Äì navega√ß√£o e coleta

void explorarSalas(Sala* atual, PistaNode** arvorePistas) {
    char opcao;

    while (atual != NULL) {
        printf("\nVoc√™ est√° em: %s\n", atual->nome);

        if (strlen(atual->pista) > 0) {
            printf("üîé Pista encontrada: %s\n", atual->pista);
            *arvorePistas = inserirPista(*arvorePistas, atual->pista);
            strcpy(atual->pista, "");
        }

        printf("\ne - esquerda | d - direita | s - sair\n");
        printf("Op√ß√£o: ");
        scanf(" %c", &opcao);

        if (opcao == 'e' && atual->esquerda)
            atual = atual->esquerda;
        else if (opcao == 'd' && atual->direita)
            atual = atual->direita;
        else if (opcao == 's')
            break;
        else
            printf("Op√ß√£o inv√°lida!\n");
    }
}


 //  verificarSuspeitoFinal ‚Äì julgamento final
   
void verificarSuspeitoFinal(PistaNode* arvorePistas) {
    char acusacao[50];

    printf("\n=== JULGAMENTO FINAL ===\n");
    printf("Suspeitos poss√≠veis:\n");
    printf("1 - Mordomo\n");
    printf("2 - Jardineiro\n");
    printf("3 - Cozinheira\n");

    printf("\nDigite o nome do suspeito: ");
    scanf(" %[^\n]", acusacao);

    int quantidade = contarPistasSuspeito(arvorePistas, acusacao);

    if (quantidade >= 2)
        printf("\n‚úî Evid√™ncias suficientes! %s √© o culpado!\n", acusacao);
    else
        printf("\n‚úò Evid√™ncias insuficientes contra %s.\n", acusacao);
}

//   MAIN ‚Äì monta sistema completo
  
int main() {

    PistaNode* arvorePistas = NULL;

    // Inicializa hash
    for (int i = 0; i < TAM_HASH; i++)
        tabelaHash[i] = NULL;

    // Mapa da mans√£o
    Sala* hall = criarSala("Hall de Entrada", "Pegadas na entrada");
    hall->esquerda = criarSala("Sala de Estar", "Ta√ßa quebrada");
    hall->direita = criarSala("Cozinha", "Faca ensanguentada");
    hall->esquerda->esquerda = criarSala("Biblioteca", "Livro rasgado");
    hall->direita->direita = criarSala("Jardim", "Luvas sujas");

    // Associa pistas a suspeitos
    inserirNaHash("Pegadas na entrada", "Jardineiro");
    inserirNaHash("Ta√ßa quebrada", "Mordomo");
    inserirNaHash("Faca ensanguentada", "Cozinheira");
    inserirNaHash("Livro rasgado", "Mordomo");
    inserirNaHash("Luvas sujas", "Jardineiro");

    printf("============================================\n");
    printf("   DETECTIVE QUEST - N√çVEL MESTRE\n");
    printf("============================================\n");

    explorarSalas(hall, &arvorePistas);

    printf("\nPistas coletadas:\n");
    exibirPistas(arvorePistas);

    verificarSuspeitoFinal(arvorePistas);

    return 0;
}
